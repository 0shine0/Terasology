/*
 * Copyright 2011 Benjamin Glatzel <benjamin.glatzel@me.com>.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.github.begla.blockmania.world;

import com.github.begla.blockmania.main.Blockmania;
import com.github.begla.blockmania.main.Configuration;
import com.github.begla.blockmania.rendering.ShaderManager;
import com.github.begla.blockmania.rendering.TextureManager;
import com.github.begla.blockmania.rendering.particles.BlockParticleEmitter;
import com.github.begla.blockmania.world.characters.Player;
import com.github.begla.blockmania.world.chunk.Chunk;
import com.github.begla.blockmania.world.chunk.ChunkMesh;
import com.github.begla.blockmania.world.horizon.Clouds;
import com.github.begla.blockmania.world.horizon.Skysphere;
import com.github.begla.blockmania.world.horizon.SunMoon;
import javolution.util.FastList;
import javolution.util.FastSet;
import org.lwjgl.opengl.GL20;
import org.lwjgl.util.vector.Vector3f;

import java.util.logging.Level;

import static org.lwjgl.opengl.GL11.*;

/**
 * The world of Blockmania. At its most basic the world contains chunks (consisting of a fixed amount of blocks)
 * and the player.
 * <p/>
 * The world is randomly generated by using a bunch of Perlin noise generators initialized
 * with a favored seed value.
 *
 * @author Benjamin Glatzel <benjamin.glatzel@me.com>
 */
public final class World extends WorldProvider {
    /* PLAYER */
    private Player _player;
    /* RENDERING */
    private FastList<Chunk> _visibleChunks = new FastList(128);
    /* PARTICLE EMITTERS */
    private final BlockParticleEmitter _blockParticleEmitter = new BlockParticleEmitter(this);
    /* HORIZON */
    private final Clouds _clouds;
    private final SunMoon _sunMoon;
    private final Skysphere _skysphere;
    protected double _daylight = 1.0f;
    /* WATER AND LAVA ANIMATION */
    private int _tick = 0;
    private long _lastTick;
    /* UPDATING */
    private final Thread _updateThread;
    private final WorldUpdateManager _worldUpdateManager;
    private boolean _updatingEnabled = false, _updateThreadAlive = true;

    /**
     * Initializes a new world for the single player mode.
     *
     * @param title The title/description of the world
     * @param seed  The seed string used to generate the terrain
     */
    public World(String title, String seed) {
        super(title, seed);

        // Init. horizon
        _clouds = new Clouds(this);
        _sunMoon = new SunMoon(this);
        _skysphere = new Skysphere(this);

        _worldUpdateManager = new WorldUpdateManager(this);
        _updateThread = new Thread(new Runnable() {

            public void run() {
                while (true) {
                    /*
                     * Checks if the thread should be killed.
                     */
                    if (!_updateThreadAlive) {
                        return;
                    }

                    /*
                     * Puts the thread to sleep
                     * if updating is disabled.
                     */
                    if (!_updatingEnabled) {
                        synchronized (_updateThread) {
                            try {
                                _updateThread.wait();
                            } catch (InterruptedException ex) {
                                Blockmania.getInstance().getLogger().log(Level.SEVERE, ex.toString());
                            }
                        }
                    }

                    _worldUpdateManager.processChunkUpdates();
                }
            }
        });
    }

    /**
     * Renders the world.
     */
    public void render() {

        _skysphere.render();

        _player.applyPlayerModelViewMatrix();

        // _sunMoon.render();

        if (!_player.isHeadUnderWater())
            _clouds.render();

        /*
        * Render the world from the player's view.
        */
        _player.render();

        renderChunks();
        renderParticleEmitters();
    }

    private void renderParticleEmitters() {
        _blockParticleEmitter.render();
    }

    private void updateParticleEmitters() {
        _blockParticleEmitter.update();
    }

    private void updateVisibleChunks() {
        _visibleChunks.clear();

        for (int x = -(Configuration.getSettingNumeric("V_DIST_X").intValue() / 2); x < (Configuration.getSettingNumeric("V_DIST_X").intValue() / 2); x++) {
            for (int z = -(Configuration.getSettingNumeric("V_DIST_Z").intValue() / 2); z < (Configuration.getSettingNumeric("V_DIST_Z").intValue() / 2); z++) {

                Chunk c = getChunkCache().loadOrCreateChunk(calcPlayerChunkOffsetX() + x, calcPlayerChunkOffsetZ() + z);

                if (c != null) {
                    if (getPlayer().getViewFrustum().intersects(c.getAABB())) {
                        _visibleChunks.add(c);
                    }
                }
            }
        }
    }


    private void updateDaylight() {
        // Sunrise
        if (getTime() < 0.1f && getTime() > 0.0f) {
            _daylight = getTime() / 0.1f;
        } else if (getTime() >= 0.1 && getTime() <= 0.5f) {
            _daylight = 1.0f;
        }

        // Sunset
        if (getTime() > 0.5f && getTime() < 0.6f) {
            _daylight = 1.0f - (getTime() - 0.5f) / 0.1f;
        } else if (getTime() >= 0.6f && getTime() <= 1.0f) {
            _daylight = 0.0f;
        }
    }

    private void renderChunks() {

        ShaderManager.getInstance().enableShader("chunk");
        int daylight = GL20.glGetUniformLocation(ShaderManager.getInstance().getShader("chunk"), "daylight");
        int swimmimg = GL20.glGetUniformLocation(ShaderManager.getInstance().getShader("chunk"), "swimming");
        int animationOffset = GL20.glGetUniformLocation(ShaderManager.getInstance().getShader("chunk"), "animationOffset");
        int animationType = GL20.glGetUniformLocation(ShaderManager.getInstance().getShader("chunk"), "animationType");
        GL20.glUniform1f(daylight, (float) getDaylight());
        GL20.glUniform1i(animationType, 0);
        GL20.glUniform1i(swimmimg, _player.isHeadUnderWater() ? 1 : 0);

        glEnable(GL_TEXTURE_2D);

        updateVisibleChunks();

        // OPAQUE ELEMENTS
        for (FastSet.Record n = _visibleChunks.head(), end = _visibleChunks.tail(); (n = n.getNext()) != end; ) {
            Chunk c = _visibleChunks.valueOf(n);

            GL20.glUniform1i(animationType, 0);
            TextureManager.getInstance().bindTexture("terrain");
            c.render(ChunkMesh.RENDER_TYPE.OPAQUE);

            // ANIMATED LAVA
            GL20.glUniform1i(animationType, 1);
            GL20.glUniform1f(animationOffset, ((float) (_tick % 16)) * (1.0f / 16f));
            TextureManager.getInstance().bindTexture("custom_lava_still");
            _visibleChunks.valueOf(n).render(ChunkMesh.RENDER_TYPE.LAVA);

            if (Configuration.getSettingBoolean("CHUNK_OUTLINES")) {
                c.getAABB().render();
            }
        }

        GL20.glUniform1i(animationType, 0);
        TextureManager.getInstance().bindTexture("terrain");

        // BILLBOARDS AND TRANSLUCENT ELEMENTS
        for (FastSet.Record n = _visibleChunks.head(), end = _visibleChunks.tail(); (n = n.getNext()) != end; ) {
            _visibleChunks.valueOf(n).render(ChunkMesh.RENDER_TYPE.BILLBOARD_AND_TRANSLUCENT);
        }

        GL20.glUniform1i(animationType, 1);

        for (int i = 0; i < 2; i++) {
            // ANIMATED WATER
            for (FastSet.Record n = _visibleChunks.head(), end = _visibleChunks.tail(); (n = n.getNext()) != end; ) {

                if (i == 0) {
                    glColorMask(false, false, false, false);
                } else {
                    glColorMask(true, true, true, true);
                }

                GL20.glUniform1f(animationOffset, ((float) (_tick / 2 % 12)) * (1.0f / 16f));
                TextureManager.getInstance().bindTexture("custom_water_still");
                _visibleChunks.valueOf(n).render(ChunkMesh.RENDER_TYPE.WATER);
            }
        }

        ShaderManager.getInstance().enableShader(null);
        glDisable(GL_TEXTURE_2D);
    }

    /**
     * Update all dirty display lists.
     */
    public void update() {
        updateDaylight();
        updateTicks();

        // Update the player
        _player.update();
        // Generate new VBOs if available
        _worldUpdateManager.updateVBOs();
        // Update the clouds
        _clouds.update();

        // Update chunks
        for (FastSet.Record n = _visibleChunks.head(), end = _visibleChunks.tail(); (n = n.getNext()) != end; )
            _visibleChunks.valueOf(n).update();

        // Update the particle emitters
        updateParticleEmitters();

        // And finally free cache space if the cache is full
        getChunkCache().freeCacheSpace();
    }

    private void updateTicks() {
        if (Blockmania.getInstance().getTime() - _lastTick >= 200) {
            _tick++;
            _lastTick = Blockmania.getInstance().getTime();
        }
    }

    public void setPlayer(Player p) {
        _player = p;
        // Reset the player's position
        resetPlayer();
    }

    /**
     * Chunk position of the player.
     *
     * @return The player offset on the x-axis
     */
    private int calcPlayerChunkOffsetX() {
        return (int) (_player.getPosition().x / Configuration.CHUNK_DIMENSIONS.x);
    }

    /**
     * Chunk position of the player.
     *
     * @return The player offset on the z-axis
     */
    private int calcPlayerChunkOffsetZ() {
        return (int) (_player.getPosition().z / Configuration.CHUNK_DIMENSIONS.z);
    }

    public void resetPlayer() {
        _player.resetEntity();
        _player.setPosition(getSpawningPoint());
    }

    public FastList<Chunk> getVisibleChunks() {
        return _visibleChunks;
    }

    public BlockParticleEmitter getBlockParticleEmitter() {
        return _blockParticleEmitter;
    }

    /**
     * Stops the updating thread and writes all chunks to disk.
     */
    public void dispose() {
        Blockmania.getInstance().getLogger().log(Level.INFO, "Disposing world {0} and saving all chunks.", getTitle());

        synchronized (_updateThread) {
            _updateThreadAlive = false;
            _updateThread.notify();
        }

        try {
            _updateThread.join();
        } catch (InterruptedException e) {

        }

        saveMetaData();
        getChunkCache().saveAndDisposeAllChunks();
    }

    /**
     * Displays some information about the world formatted as a string.
     *
     * @return String with world information
     */
    @Override
    public String toString() {
        return String.format("world (time: %f, sun: %f, cdl: %d, cn: %d, cache: %d, ud: %fs, seed: \"%s\", title: \"%s\")", getTime(), _skysphere.getSunPosAngle(), _worldUpdateManager.getVboUpdatesSize(), _worldUpdateManager.getUpdatesSize(), _chunkCache.size(), _worldUpdateManager.getMeanUpdateDuration() / 1000d, _seed, _title);
    }

    /**
     * Starts the updating thread.
     */
    public void startUpdateThread() {
        _updatingEnabled = true;
        _updateThread.start();
    }

    /**
     * Resumes the updating thread.
     */
    public void resumeUpdateThread() {
        _updatingEnabled = true;
        synchronized (_updateThread) {
            _updateThread.notify();
        }
    }

    /**
     * Safely suspends the updating thread.
     */
    public void suspendUpdateThread() {
        _updatingEnabled = false;
    }

    public void setSpawningPointToPlayerPosition() {
        _spawningPoint = new Vector3f(_player.getPosition());
    }

    public Player getPlayer() {
        return _player;
    }

    @Override
    public Vector3f getOrigin() {
        return _player.getPosition();
    }

    public boolean isChunkVisible(Chunk c) {
        return _player.getViewFrustum().intersects(c.getAABB());
    }

    /**
     * Returns the daylight value.
     *
     * @return The daylight value
     */
    public double getDaylight() {
        return _daylight;
    }
}
